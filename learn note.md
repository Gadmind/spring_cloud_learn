# spring_cloud_learn_note
版本要求

```
java: 8
maven: 3.5及以上
mysql：5.7及以上
spring-cloud-version: Hoxton.SR8
spring-boot-version: 2.3.3.RELEASE
spring-cloud-alibaba-version: 2.2.1.RELEASE
```

**服务注册与发现之Eureka**

什么是服务治理？

SpringCloud封装了Netflix公司开发的Eureka模块来实现服务治理

在传统RPC远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以就需要服务治理，管理服务与服务之间的依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册

什么是服务注册与发现？

Eureka采用了CS的设计架构，EurekaServer作为服务注册功能的服务器，它是服务注册中心，而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接，这样系统维护人员可以通过EurekaServer来监控系统中各个微服务是否正常运行。

在服务注册与发现中，有一个注册中心。当服务其启动的时候，会把当前自己服务器的信息，比如，服务器地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后在实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何RPC远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址））

Eureka包含两个组件：EurekaServer和EurekaClient

- Eureka Server提供服务注册服务

  各个微服务几点通过配置启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到

- Eureka Client通过注册中心进行访问

  是一个Java客户端。用于简化EurekaServer的交互，客户端同时也具备一个内置的、使用轮询（round-robin）负载算法的负载均衡器。在应用启动后，回向EurekaServer发送心跳（默认周期30秒）。如果EurekaServer在多个心跳周期内没有接收到某个节点的心跳。EurekaServer会将这个服务从服务注册表中移除（默认90秒）

服务注册：将服务信息注册进注册中心；服务发现：从注册中心上获取服务信息；实质：存key服务名，取value调用地址

ServicePovider：先启动Eureka注册中心；启动服务提供者；服务提供者七佛那个后会把自身信息（如服务地址以别名方式注册进Eureka）；消费者服务在需要调用接口时，使用服务别名去注册中心，获取实际的RPC远程调用地址；消费者获取调用地址之后，底层使用HttpClient技术实现远程调用；消费者获得服务地址后会缓存在本地JVM内存中，默认每间隔30秒更新一次服务调用地址。

> 在`C:\Windows\System32\drivers\et`目录下修改hosts文件配置Eureka集群
>
> ```
> #######SpringCloud################
> 127.0.0.1       eureka7001.com
> 127.0.0.1       eureka7002.com
> 127.0.0.1       eureka7003.com
> ```

服务发现Discovery

Eureka自我保护

出现这样一段话**EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.**

某一时刻某一服务不可用了，Eureka不会立即清除，依旧会对该服务的信息进行保存，属于CAP理论中的AP分支

为什么会产生Eureka自我保护机制？

为了防止EurekaClient可以正常运行，但是与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务器剔除

什么是自我保护模式？

默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生时（延时、卡顿、拥挤）时，微服务与Eureka Server之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身是健康的，此时不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障）那么这个节点就会进入自我保护模式

在自我保护模式中，EurekaServer会保护服务注册表中的信息，不在注销任何服务实例，它的设计就是宁可保留错误的服务注册信息，也不盲目的注销任何可能健康的服务实例，

自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务，使用自我保护模式，让Eureka集群更加健壮，稳定

**服务注册发现之Zookeeper**

临时节点（CP原理）

**服务注册发现之Consul**

（CP原理）

|  组件名   | 语言 | CAP  | 健康服务检查 | 对外暴露接口 | spring Cloud集成 |
| :-------: | :--: | :--: | :----------: | :----------: | :--------------: |
|  Eureka   | Java |  AP  |   可配支持   |     HTTP     |      已集成      |
|  Consul   |  Go  |  CP  |     支持     |   HTTP/DNS   |      已集成      |
| Zookeeper | Java |  CP  |     支持     |    客户端    |      已集成      |

**CAP理论核心**：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个要求，因此根据CAP理论将NoSQL数据库分成了满足CA原则、CP原则和满足AP原则三大类；CAP理论关注粒度是数据，而不是整体系统设计的策略

**C（Consistency）**：强一致性

**A（Availability）**：可用性

**P（Partition Tolerance）**：分区容错性

**AP架构**：当网络分区出现后，为了保证可用性，其他服务可以返回旧值，保证系统的可用性，违背一致性C的要求只满足可用性和分区容错性即AP

**CP架构**：当网络分区出现后，为了保证数据一致性，就拒绝请求，否则无法保证一致性，违背可用性A的要求，只满足一致性和分区容错性即CP

**CA**：单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大，例如：RDEMS

**CP**：满足一致性，分区容忍性的系统，通常性能不是特别高，例如：MongoDB、HBase、Redis

**AP**：满足可用性，分区容忍性的系统，通常可能对一致性要求低一些，例如：CouchDB、Cassandra、DynamoDB

**什么是负载均衡**

将客户的请求平摊到多个服务器上，从而达到系统的HA（高可用）。常见的负载均衡软件有Nginx、LVS、硬件F5等。

**集中式LB和进程式LB**

集中式：在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx），由该设施把访问请求通过某种策略转发至服务的提供方

进程式：将LB逻辑集成到消费方，消费方从服务注册中心获取有那些地址可用，然后自己再从这些地址中选一个合适的服务器。Ribbon就是进程式LB，它是一个类库，继承与消费方进程，消费方通过他来获取到服务器提供方的地址

**Ribbon本地负载均衡和Nginx服务端负载均衡区别**

Nginx是服务器负载均衡，客户端所有服务都会交给nginx，然后由Nginx转发请求，及负载均衡是由服务端实现的（集中式LB）

Ribbon是本地负载均衡，在微服务调用接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现PRC远程服务调用技术（进程式LB）



**负载均衡之Ribbon**（负载均衡+RestTemplate）

Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具，主要功能是提供客户端的软件负载均衡算法和服务调用，Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单说就是配置文件中列出的LoadBalancer（简称LB），后面所有机器Ribbon会自动的帮助你基于某种规则（如简单轮询，随机链接等）去连接这些机器，可很容易的使用Ribbon实现自定义的负载均衡算法

**Ribbon核心组件IRule**

根据算法特点从服务列表中选取一个要访问的服务

**Ribbon负载均衡算法**

**轮询原理**：rest接口第几次请求数%服务器集群总数=实际调用服务器位置下标，每次服务重启后rest接口计数从1开始（取模操作）

**服务接口调用OpenFeign**

Feign是一个声明式的WebService客户端，简化Web客户服务端编码 通过定义一个服务接口然后在上面添加注解

在项目中服务依赖的调用可能不止一处，往往一个接口会被多次调用，所以通常会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，只用创建一个接口并通过注解（@Feign）方式来配置，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。

Feign集成了Ribbon利用Ribbon维护了提供者的服务列表信息，并通过轮询实现客户端的负载均衡。与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，简单优雅的实现了服务调用

|                            Feign                             | OpenFeign                                                    |
| :----------------------------------------------------------: | :----------------------------------------------------------- |
| Fegin是SpringCloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负责负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign注解定义接口，调用这个接口，就可以调用服务注册中心的服务 | OpenFegin是SpringCloud在Feign基础上支持了SpringMVC的注解，如@RequestMapping等。OpenFeign的注解@FeignClient可以解析SpringMVC的@RequespMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务 |

Feign默认请求等待时间为1秒可以通过配置文件来进行设置

日志级别

1. NONE：默认的不显示任何日志
2. BASIC：仅记录请求方法、URL、响应状态码及执行时间
3. HEADERS：除了BASIC中定义的信息外，还有请求和响应的头信息
4. FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据

**服务降级熔断之Hystrix**

分布式系统面临的问题

服务雪崩，多个服务之间调用的时候，假设服务A调服务B和服务C，服务B和服务C又调用其他服务，这就是所谓的“扇出”，如果扇出链路上的某个服务的调用的响应时间太长或不可用，对服务A的调用就会占用越要越多的资源，从而导致系统崩溃，所谓的”雪崩效应“

对于高流量的应用来说，单一的后端依赖可能导致所有服务器上所有资源在几秒钟内饱和，比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都是表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或者系统。所以，当一个模块下的某个实例失败后，这时候模块依旧会接受流量，然后这个有问题的模块还调用了其他模块，这就会发生级联故障，或叫雪崩

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保障在一个以来出问题的情况下，不会导致导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

“断路器”本身是一种开关装置，当某个服务单元故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩

重要概念

- 服务降级（fallback）：服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好的提示，服务降级的情况：程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满也会导致服务降级

- 服务熔断（break）：类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示，服务的降级—>进而熔断—>恢复调用链路；服务熔断是服务降级的一种更直接的保护，当请求请求失败数达到设定的阈值就会开启熔断机制，之后的请求直接进入fallback，会在限定的时间内进行请求重试，放行小部分请求，当服务恢复正常会关闭熔断机制

  熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务出错或响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息，当检测到该节点微服务相应正常后，恢复调用链路，在Spring Cloud中通过Hystrix实现，失败调用达到一定阈值进行熔断，5秒内20次调用失败，会触发熔断机制，通过注解@HystrixCommand

  熔断类型

  熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间），当打开时长达到所设时钟则进入半熔断状态

  熔断关闭：熔断关闭不会对服务进行熔断

  熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断

  **断路器起作用的情况及三个重要参数（快照时间窗、请求总数阈值、错误百分比与之）**

  **快照时间窗**：断路器确定是否打开需要统计一些请求和错误数据，而统计时间范围就是快照时间窗，默认为最近的10秒

  **请求总数阈值**：在快照时间窗内，必须满足请求总数阈值才有资格熔断，默认为20，意味着在10秒内，如果该Hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器也不会打开

  **错误百分比阈值**：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，且在30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阈值的情况下，断路器会打开

  当断路器打开之后，所有的请求调用将不会调用主逻辑，而是直接调用降级fallback，通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟效果。

  对主逻辑进行熔断之后，Hystrix启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的主逻辑，当休眠时间窗到期后，断路器进入半开状态，释放一次请求来到原来的主逻辑上，如果此次请求正常返回，那么短路器继续闭合，主逻辑恢复，如果这次请求有问题，断路器继续进入打开状态，休眠时间窗重新计时。

- 服务限流（flowlimit）：秒杀高并发等操作，严禁一窝蜂的涌过来，大家排队，一秒N个，有序进行

**服务网关之Gateway**

动态路由（Route）、断言（Predicate）、过滤器（Filter）、集成断路器、集成服务发现、请求限流、路径重写

Zuul1.x基于Servlet2.5阻塞I/O的Gateway,Zuul2.x基于Netty非阻塞支持长连接

SpringCloudGateway 

路由（Route）：是构建网关的基本模块，由ID，目标URI，一系列的断言和过滤器组成，如果断言为True则匹配该路由

断言（Predicate）：通过匹配HTTP请求中的所有内容（例如请求头或请求参数）如果请求与断言相匹配则进行路由。可参考java8包下的java.util.function.Predicate

过滤器（Filter）：指的是Spring框架中GatewayFilter实例，使用过滤器，可在请求被路由前或之后对请求进行修改

 流程：web请求通过匹配条件定位到真正的服务节点，并在转发前后进行精细化管理，Predicate是匹配条件，Filter作为拦截器对请求进行拦截过滤，两个元素加上URI即可实现具体路由

**服务配置之Config**

为微服务架构中的为服务提供集中的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置

`curl -X POST "http://localhost:3355/actuator/refresh"`

**服务消息总线之Bus**

支持RabbitMQ和Kafaka

SpringCloudBus能管理和传播分布式系统之间的消息，像一个分布式执行器，用于广播状态更改，事件推送等，也可以当作微服务之间的通信通道

**什么是总线**

在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来，由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线，总线上的各个实例，都可以方便的广播一些需要让其他连接在该主题上的实例都知道的消息

**原理**：客户端实例监听MQ中的同一个Topic （默认是SpringCloudBus）。当一个服务刷新数据时，它会把这个信息放入到Topic中，这样其他监听同一Topic的服务就能得到通知，然后更新自身配置

不同组是可以全面消费（重复消费）

相同组会发生竞争关系，只有其中一个可以消费

**分布式请求链路跟踪Sleuth**

客户端发起请求，后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败

zikpin：trace：类似于树结构的span集合，表示一条调用链路，存在唯一标识；Span：表示调用链路来源，通俗的理解span就是一次请求信息

## SpringCloudAlibaba

Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。

依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统

[Spring Cloud Alibaba官网](https://spring.io/projects/spring-cloud-alibaba#overview)

[Github英文文档](https://github.com/alibaba/spring-cloud-alibaba)

[Spring英文文档](https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html)

[Github中文](https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md)

**Spring Cloud Alibaba主要功能**

- **服务降级限流**：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，还支持查看限流降级Metrics监控。
- **服务注册与发现**：适配Spring Cloud服务注册与发现的标准，默认集成了Ribbon的支持
- **分布式管理配置**：支持分布式系统中的外部化配置，配置更改时自动刷新
- **消息驱动能力**：基于Spring Cloud Stream为微服务应用构建消息驱动能力
- **分布式事务**：使用@GlobalTransactional注解，高效并且对业务零侵入的解决分布式事务问题
- **阿里云对象存储**：阿里云提供的海量、安全、低成本、高可用的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据
- **分布式服务调度**：提供秒级、精准、高可靠、高可用的定时（基于Cron表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker（Schedulex-client）上执行
- **阿里云短息服务**：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。

**Spring Cloud Alibaba包含的组件**

1. **Sentinel**：阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
2. **Nacos**：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
3. **RocketMQ**：Apache RocketMQ™基于Java的高性能、高吞吐量的分布式消息和计算平台，一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。
4. **Dubbo**：Apache Dubbo™是一款高性能的Java RPC框架
5. **Seate**：阿里巴巴开源产品，一个易于使用的高性能为服务分布式事务解决方案。
6. **Alibaba Cloud OSS**：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。
7. **Alibaba Cloud SchedulerX**：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。
8. **Alibaba Cloud SMS**：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。

**服务注册和配置中心之Spring Cloud Alibaba Nacos**

**什么是Nacos**（AP模型）

Nacos（Dynamic Naming and Configuration *S*ervice）一个更易于构建云原生应用的动态服务发现、服务配置和服务管理平台，就是Naocs = 注册中心 + 配置中心 =Spring Cloud Netflix Eureka + Spring Cloud Config +Spring Cloud  Bus

**服务注册中心对比**

|                  |           Naocs           |   Eureka   |      Consul       | CoreDNS | Zookeeper  |
| :--------------: | :-----------------------: | :--------: | :---------------: | :-----: | :--------: |
|    一致性协议    |           CP+AP           |     AP     |        CP         |    /    |     CP     |
|     健康检查     | TCP/HTTP/MySQL/ClientBeat | ClientBeat | TCP/HTTP/gRPC/CMD |    /    | ClientBeat |
|     负载均衡     |  权重/DSL/metadata/CMDB   |   Ribbon   |       Fabio       |   RR    |     /      |
|     雪崩保护     |           支持            |    支持    |      不支持       | 不支持  |   不支持   |
|   自动注销实例   |           支持            |    支持    |      不支持       | 不支持  |   不支持   |
|     访问协议     |       HTTP/DNS/UDP        |    HTTP    |     HTTP/DNS      |   DNS   |    TCP     |
|     监听支持     |           支持            |    支持    |       支持        | 不支持  |    支持    |
|    多数据中心    |           支持            |    支持    |       支持        | 不支持  |   不支持   |
|    跨注册中心    |           支持            |   不支持   |       支持        | 不支持  |   不支持   |
| Spring Cloud集成 |           支持            |    支持    |       支持        | 不支持  |   不支持   |
|    Dubbo集成     |           支持            |   不支持   |      不支持       | 不支持  |    支持    |
|     K8s集成      |           支持            |   不支持   |       支持        |  支持   |   不支持   |

**NaocsAP模型和CP模型切换**

C是所有节点在同一时间看到的数据是一致的，A定义是所有的请求都会收到回应

一般来说，如果不需要存储服务级别的信息且服务实力是通过nacos-client注册，并且能够保持心跳上报，那么就可以选择AP模式，当前主流的服务如Spring Cloud 和Dubbo服务，都是用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模型只支持注册临时实例

如果需要在服务级别编辑或存储配置信息，那么CP是必须，K8s服务和DNS服务则适用于CP模式，CP模式下则注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例前必须先注册服务，如果服务不在，则返回错误

`curl -X PUT '$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&value=CP'`



**服务熔断与限流之Spring Cloud Alibaba Sentinel**

**流控规则**

- **资源名**：唯一名称，默认请求路径
- **针对来源**：Sentinel可以针对调用者进行限流，填写为服务名，默认default（不区分来源）
- **阈值类型/单机阈值**：
  - QPS：（每分钟的请求数量）当调用当前API的QPS达到阈值时，进行限流
  - 线程数：当调用当前API的线程数达到阈值时，进行限流
- **是否集群**：不需要集群
- **流控模式**：
  - 直接：api达到限流条件时，直接限流
  - 关联：当关联的资源达到阈值时，就限流自己
  - 链路：只记录制定链路上的流量（指定资源从入资源进来的流量，如果达到阈值，就进行限流）[API级别的针对来源]
- **流控效果**：
  - 快速失败：直接失败，抛异常
  - Warm Up：根据codeFactor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值
  - 排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效

**降级规则**

1. **慢调用比例（RT 秒级）**：平均响应时间  超出阈值 且 在时间窗口内通过的请求>=5， 两个条件满足后触发降级，窗口期过后关闭断路器，RT最大4900（更大的需要通过`-Dcsp.sentinel.statistic.max.rt=xxx`设置才能生效
2. **异常比例（秒级）**：QPS>=5 且 异常比例（秒级统计）超过阈值时，触发降级，时间窗口结束后，关闭降级
3. **异常数（分钟级）**：异常数（分钟统计）超过阈值，触发降级，时间窗口结束后，关闭降级

sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（比如调用超时或者异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其他的资源而导致的级联错误，当资源被降级后，在接下来的降级时间窗口内，对该资源的调用都自动熔断（默认行为是抛出DegradeException）没有半开状态

**热点规则**

通过`@SentinelResouece`注解来规定控制台违规情况，有blockHandler方法配置的兜底处理

但是当程序报出RuntimeException时 `@SentinelResource`不做处理

**系统规则**

系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。

系统保护规则是应用整体维度的，而不是资源维度的，并且**仅对入口流量生效**。入口流量指的是进入应用的流量（`EntryType.IN`），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。

**系统规则支持的模式**

- **Load自适应**（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 `maxQps * minRt` 估算得出。设定参考值一般是 `CPU cores * 2.5`。
- **CPU Usage**：（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。
- **平均RT**：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。
- **并发线程数**：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。
- **入口QPS**：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。

**`@SentinelResource`详解**

